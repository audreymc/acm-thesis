---
title: "Time Series Forecasting: Market Data"
author: "Audrey McMillion"
date: '2025-04-14'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Testing: ARIMA-GARCH Modelling
Using the ``rugarch`` package, we will test a simple ARMA-GARCH model.  

```{r test-package}
require(rugarch)

data <- rnorm(1000)
spec <- ugarchspec(variance.model = list(model = "sGARCH", 
                                         garchOrder = c(1, 1), 
                                         submodel = NULL, 
                                         external.regressors = NULL, 
                                         variance.targeting = FALSE), 

                   mean.model     = list(armaOrder = c(1, 1), 
                                         external.regressors = NULL, 
                                         distribution.model = "norm", 
                                         start.pars = list(), 
                                         fixed.pars = list()))

garch <- ugarchfit(spec = spec, data = data, solver.control = list(trace=0))

## extract resulting series
mu. <- fitted(garch) # fitted hat{mu}_t (= hat{X}_t)
sig. <- sigma(garch) # fitted hat{sigma}_t

## Plot data X_t and fitted hat{mu}_t
plot(data, type = "l", xlab = "t",
     ylab = expression("Data"~data[t]~"and fitted values"~hat(mu)[t]))
lines(as.numeric(mu.), col = adjustcolor("blue", alpha.f = 0.5))
legend("bottomright", bty = "n", lty = c(1,1),
       col = c("black", adjustcolor("blue", alpha.f = 0.5)),
       legend = c(expression(X[t]), expression(hat(mu)[t])))
```

```{r outputs}
# coefficients
garch@fit$coef

# residual plot
plot(garch@fit$residuals)

# get the GARCH fit output
# garch@fit

# string
# str(garch) # see what we can use from the fit
```
## Market Data Example

```{r read-data}
library(RPostgres)
wrds <- dbConnect(Postgres(),
                  host='wrds-pgdata.wharton.upenn.edu',
                  port=9737,
                  dbname='wrds',
                  sslmode='require',
                  user = Sys.getenv("WRDS_USER"),
                  password = Sys.getenv("WRDS_PASSWORD"))
```

For this, we are considering FLL which may have been subject to distribution shift/non-stationary behavior.

```{r fll_datapull}
library(tidyverse)
library(ggplot2)

res <- dbSendQuery(wrds, "
SELECT *
FROM (
      SELECT b.ticker,
              a.permno,
              a.dlycaldt,
              a.dlyopen,
              coalesce(a.dlyclose, a.dlyprc) AS dlyclose,
              a.dlyhigh,
              a.dlylow,
              a.dlynumtrd,
              a.dlyvol,
              a.dlyhigh - a.dlylow AS highlow,
              LAG(a.dlyopen) OVER (ORDER BY a.dlycaldt) AS prevopen,
              LAG(a.dlyclose) OVER (ORDER BY a.dlycaldt) AS prevclose,
              LAG(a.dlyhigh) OVER (ORDER BY a.dlycaldt) AS prevhigh,
              a.dlyclose - LAG(a.dlyclose) OVER (ORDER BY a.dlycaldt) AS dlyreturn,
              ln(a.dlyhigh) - LAG(ln(a.dlyhigh)) OVER (ORDER BY a.dlycaldt) AS dlyhighreturn,
              (a.dlyhigh  - a.dlylow) AS highlow,
              (a.dlyhigh  - a.dlylow) - LAG((a.dlyhigh  - a.dlylow)) OVER (ORDER BY a.dlycaldt) AS highlow_diff,
              ln(a.dlyhigh / a.dlylow) AS log_highlow
      FROM crsp.dsf_v2 a
      JOIN crsp.dsenames AS b
      ON a.permno = b.permno
      AND b.ticker = 'BKNG'
      AND a.dlycaldt BETWEEN date('2019-03-01') AND date('2020-03-31')
      AND date('2020-03-31') BETWEEN b.namedt AND b.nameendt
    )
    WHERE dlyreturn IS NOT NULL
    ORDER BY dlycaldt
")
fll_data <- dbFetch(res)

ggplot(fll_data, aes(x = dlycaldt, y = log_highlow)) +
  geom_line(color = "blue", size = 1) +
  labs(title = "FLL Daily Log High/Low", x = "Date", y = "log_highlow") +
  theme_minimal()
```
```{r}
# difference the data to get high/low "returns"
series <- diff(fll_data$log_highlow)

# plot series
plot(series, type='l')
```

Run the Dickey Fuller test for the unit root.  

```{r test_unit_root}
library(tseries)
adf.test(series)
```
Conclusion: the series is stationary. We will now try fitting an ARIMA-GARCH model to the data.  
```{r}
library(forecast)
fit <- auto.arima(series, max.p=10, max.q=10, max.order = 20, stepwise=FALSE, seasonal=FALSE, trace=TRUE)
```


Now, test for ARCH effects using the Box-Ljung test. 

```{r}
library(nortsTest)
arch.test(series, arch = "box", alpha = 0.05, lag.max = 12)
```
Conclusion: the series is hetero-scedastic.

```{r}
spec <- ugarchspec(variance.model = list(model = "sGARCH", 
                                         garchOrder = c(1, 1), 
                                         submodel = NULL, 
                                         external.regressors = NULL, # introduce external regressors
                                         variance.targeting = FALSE), 

                   mean.model     = list(armaOrder = c(2, 4), 
                                         external.regressors = NULL # introduce external regressors 
                                        ))

garch <- ugarchfit(spec = spec, data = series, solver.control = list(trace=0))
show(garch)
```
View model coefficients.

```{r}
# get coefficients
garch@fit$coef
```

```{r}
library(nortsTest)

# assess the residuals
resid <- residuals(garch, standardize=TRUE)
plot(resid)

# plot ACF and PACF
acf(resid, main = "ACF of Standardized Residuals")
pacf(resid, main = "PACF of Standardized Residuals")

# test for residual heteroske
arch.test(resid, arch = "box", alpha = 0.05, lag.max = 2)
```

```{r}
## extract resulting series
mu. <- fitted(garch) # fitted hat{mu}_t (= hat{X}_t)
sig. <- sigma(garch) # fitted hat{sigma}_t

## Plot data X_t and fitted hat{mu}_t
plot(series, type = "l", xlab = "t",
     ylab = expression("Data"~fll_data[t]~"and fitted values"~hat(mu)[t]))
lines(as.numeric(mu.), col = adjustcolor("blue", alpha.f = 0.5))
legend("bottomright", bty = "n", lty = c(1,1),
       col = c("black", adjustcolor("blue", alpha.f = 0.5)),
       legend = c(expression(X[t]), expression(hat(mu)[t])))
```
```{r}
# get the conditional variance
cond_var <- sigma(garch)^2

# get squared residuals (actual volatility proxy)
residuals_sq <- residuals(garch)^2

# plot
graphics.off()
plot(residuals_sq, type = "l", col = "gray", main = "GARCH Conditional Variance vs Squared Residuals",
     ylab = "Variance", xlab = "Time")
lines(cond_var, col = "red", lty = 2)
legend("topright", legend = c("Squared Residuals", "GARCH Conditional Variance"),
       col = c("gray", "red"), lty = c(1, 2))
```
```{r}
# get the standardized residuals
resid_std <- residuals(garch, standardize = TRUE)

# plot diagnostics
plot(garch)

# arch test of standardized residuals
arch.test(resid_std, arch = "box", alpha = 0.05, lag.max = 12)
```

## ACD-GARCH Modeling
We can use the package ``racd-package`` in combination with ``rugarch`` for Autoregressive Conditional Density models.

```{r}
library(ACDm)
library(rugarch)

# Simulated data (replace this with your actual intraday data)
set.seed(123)
n <- 1000
timestamps <- cumsum(rexp(n, rate=1/30))  # irregular event times (avg 30s apart)
log_prices <- cumsum(rnorm(n, sd=0.001))
returns <- diff(log_prices)
durations <- diff(timestamps)  # durations in seconds

# Step 1: Fit ACD model on durations
acd_model <- acdFit(durations, dist = "exponential", model = "ACD", order = c(1,1))
predicted_duration <- predict(acd_model, n.ahead = 1)

# Step 2: Fit GARCH model on returns
spec <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
  mean.model = list(armaOrder = c(0, 0), include.mean = FALSE),
  distribution.model = "norm"
)
garch_fit <- ugarchfit(spec, returns)

# Step 3: Forecast next-step volatility
garch_forecast <- ugarchforecast(garch_fit, n.ahead = 1)
sigma_next <- sigma(garch_forecast)

# Step 4: Scale volatility using predicted duration (ACD adjustment)
# Intensity is inverse of duration; normalize it to avoid exploding
duration_scale <- sqrt(mean(durations) / predicted_duration)
adjusted_sigma <- sigma_next * duration_scale

# Step 5: Compute 99% VaR (z = 2.33 for normal) and 1% VaR (z = -2.33 for normal)
z_99 <- qnorm(0.01)  # z-score for 99% confidence (lower tail)
z_1 <- qnorm(0.99)   # z-score for 1% confidence (upper tail)

# Calculate the upper and lower quantiles for the 99% confidence interval
VaR_99 <- -z_99 * adjusted_sigma
VaR_1 <- -z_1 * adjusted_sigma

# Display the result (confidence interval range)
cat("95% confidence interval for next-step return:\n")
cat("Lower bound (1% quantile):", round(VaR_1, 6), "\n")
cat("Upper bound (99% quantile):", round(VaR_99, 6), "\n")


```